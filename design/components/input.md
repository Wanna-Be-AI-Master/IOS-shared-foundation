# Input ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆä»•æ§˜

## æ¦‚è¦

ãƒ†ã‚­ã‚¹ãƒˆå…¥åŠ›ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã®ä»•æ§˜ã‚’å®šç¾©ã™ã‚‹ã€‚

---

## ãƒãƒªã‚¨ãƒ¼ã‚·ãƒ§ãƒ³

### ã‚¿ã‚¤ãƒ—

| ã‚¿ã‚¤ãƒ— | èª¬æ˜ | ç”¨é€” |
|--------|------|------|
| **Text** | æ¨™æº–ãƒ†ã‚­ã‚¹ãƒˆå…¥åŠ› | åå‰ã€ãƒ¡ãƒ¢ |
| **Email** | ãƒ¡ãƒ¼ãƒ«å½¢å¼ | ãƒ¡ãƒ¼ãƒ«ã‚¢ãƒ‰ãƒ¬ã‚¹ |
| **Password** | ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ï¼ˆãƒã‚¹ã‚¯ï¼‰ | ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰å…¥åŠ› |
| **Number** | æ•°å€¤å…¥åŠ› | æ•°é‡ã€é‡‘é¡ |
| **Phone** | é›»è©±ç•ªå· | é›»è©±ç•ªå· |
| **Multiline** | è¤‡æ•°è¡Œãƒ†ã‚­ã‚¹ãƒˆ | é•·æ–‡å…¥åŠ› |

### ã‚µã‚¤ã‚º

| ã‚µã‚¤ã‚º | é«˜ã• | ãƒ•ã‚©ãƒ³ãƒˆã‚µã‚¤ã‚º | ç”¨é€” |
|--------|------|----------------|------|
| Small | 40px | 14px | ã‚³ãƒ³ãƒ‘ã‚¯ãƒˆãªãƒ•ã‚©ãƒ¼ãƒ  |
| Medium | 48px | 16px | æ¨™æº–ãƒ•ã‚©ãƒ¼ãƒ  |
| Large | 56px | 18px | é‡è¦ãªå…¥åŠ› |

---

## ãƒ“ã‚¸ãƒ¥ã‚¢ãƒ«ä»•æ§˜

### åŸºæœ¬æ§‹é€ 

```
â”Œâ”€ ãƒ©ãƒ™ãƒ«ï¼ˆä»»æ„ï¼‰â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                                     â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚ ğŸ” ãƒ—ãƒ¬ãƒ¼ã‚¹ãƒ›ãƒ«ãƒ€ãƒ¼      âœ•  â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                     â”‚
â”‚  ãƒ˜ãƒ«ãƒ‘ãƒ¼ãƒ†ã‚­ã‚¹ãƒˆ / ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### å¯¸æ³•

```
å¤–å´ãƒãƒ¼ã‚¸ãƒ³: 0
å†…å´ãƒ‘ãƒ‡ã‚£ãƒ³ã‚°: 12px 16px
è§’ä¸¸: 12px
ãƒœãƒ¼ãƒ€ãƒ¼å¹…: 1pxï¼ˆãƒ•ã‚©ãƒ¼ã‚«ã‚¹æ™‚ 2pxï¼‰
```

### ã‚¢ã‚¤ã‚³ãƒ³

| ä½ç½® | ã‚µã‚¤ã‚º | ãƒãƒ¼ã‚¸ãƒ³ |
|------|--------|----------|
| Leadingï¼ˆå·¦ï¼‰ | 20px | å³ 8px |
| Trailingï¼ˆå³ï¼‰ | 20px | å·¦ 8px |

---

## çŠ¶æ…‹

### ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ (Default)

```
èƒŒæ™¯: #F5F5F5 (Light) / #2A2A2A (Dark)
ãƒœãƒ¼ãƒ€ãƒ¼: ãªã— or #E0E0E0
ãƒ†ã‚­ã‚¹ãƒˆ: ãƒ—ãƒ©ã‚¤ãƒãƒªãƒ†ã‚­ã‚¹ãƒˆè‰²
ãƒ—ãƒ¬ãƒ¼ã‚¹ãƒ›ãƒ«ãƒ€ãƒ¼: ã‚»ã‚«ãƒ³ãƒ€ãƒªãƒ†ã‚­ã‚¹ãƒˆè‰²
```

### ãƒ•ã‚©ãƒ¼ã‚«ã‚¹ (Focused)

```
èƒŒæ™¯: #FFFFFF (Light) / #3A3A3A (Dark)
ãƒœãƒ¼ãƒ€ãƒ¼: 2px solid ãƒ—ãƒ©ã‚¤ãƒãƒªã‚«ãƒ©ãƒ¼
ã‚·ãƒ£ãƒ‰ã‚¦: 0 0 0 3px rgba(primary, 0.1)
```

### å…¥åŠ›æ¸ˆã¿ (Filled)

```
èƒŒæ™¯: ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã¨åŒã˜
ãƒœãƒ¼ãƒ€ãƒ¼: #E0E0E0
ãƒ†ã‚­ã‚¹ãƒˆ: ãƒ—ãƒ©ã‚¤ãƒãƒªãƒ†ã‚­ã‚¹ãƒˆè‰²
```

### ã‚¨ãƒ©ãƒ¼ (Error)

```
èƒŒæ™¯: rgba(error, 0.05)
ãƒœãƒ¼ãƒ€ãƒ¼: 2px solid ã‚¨ãƒ©ãƒ¼ã‚«ãƒ©ãƒ¼
ãƒ˜ãƒ«ãƒ‘ãƒ¼ãƒ†ã‚­ã‚¹ãƒˆ: ã‚¨ãƒ©ãƒ¼ã‚«ãƒ©ãƒ¼
ã‚¢ã‚¤ã‚³ãƒ³: ã‚¨ãƒ©ãƒ¼ã‚¢ã‚¤ã‚³ãƒ³ï¼ˆå³å´ï¼‰
```

### ç„¡åŠ¹ (Disabled)

```
èƒŒæ™¯: #F0F0F0
ãƒœãƒ¼ãƒ€ãƒ¼: #E0E0E0
ãƒ†ã‚­ã‚¹ãƒˆ: #999999
ä¸é€æ˜åº¦: 60%
æ“ä½œ: ä¸å¯
```

---

## ãƒ©ãƒ™ãƒ«ã¨ãƒ˜ãƒ«ãƒ‘ãƒ¼ãƒ†ã‚­ã‚¹ãƒˆ

### ãƒ©ãƒ™ãƒ«

| å±æ€§ | å€¤ |
|------|-----|
| ä½ç½® | å…¥åŠ›ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã®ä¸Š |
| ãƒ•ã‚©ãƒ³ãƒˆã‚µã‚¤ã‚º | 14px |
| ãƒ•ã‚©ãƒ³ãƒˆã‚¦ã‚§ã‚¤ãƒˆ | 500 (Medium) |
| ãƒãƒ¼ã‚¸ãƒ³ä¸‹ | 6px |
| è‰² | ãƒ—ãƒ©ã‚¤ãƒãƒªãƒ†ã‚­ã‚¹ãƒˆè‰² |

### å¿…é ˆãƒãƒ¼ã‚¯

```
ãƒ©ãƒ™ãƒ« *

* ã¯èµ¤è‰²ï¼ˆã‚¨ãƒ©ãƒ¼ã‚«ãƒ©ãƒ¼ï¼‰
```

### ãƒ˜ãƒ«ãƒ‘ãƒ¼ãƒ†ã‚­ã‚¹ãƒˆ

| å±æ€§ | å€¤ |
|------|-----|
| ä½ç½® | å…¥åŠ›ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã®ä¸‹ |
| ãƒ•ã‚©ãƒ³ãƒˆã‚µã‚¤ã‚º | 12px |
| ãƒãƒ¼ã‚¸ãƒ³ä¸Š | 4px |
| è‰² | ã‚»ã‚«ãƒ³ãƒ€ãƒªãƒ†ã‚­ã‚¹ãƒˆè‰²ï¼ˆé€šå¸¸ï¼‰ / ã‚¨ãƒ©ãƒ¼è‰²ï¼ˆã‚¨ãƒ©ãƒ¼æ™‚ï¼‰ |

---

## æ–‡å­—æ•°ã‚«ã‚¦ãƒ³ã‚¿ãƒ¼

### è¡¨ç¤ºæ¡ä»¶

- `maxLength` ãŒè¨­å®šã•ã‚Œã¦ã„ã‚‹å ´åˆ
- å…¥åŠ›æ–‡å­—æ•°ãŒ `maxLength * 0.8` ã‚’è¶…ãˆãŸå ´åˆï¼ˆã‚ªãƒ—ã‚·ãƒ§ãƒ³ï¼‰

### è¡¨ç¤ºå½¢å¼

```
123 / 500

ä½ç½®: å³ä¸‹
ãƒ•ã‚©ãƒ³ãƒˆã‚µã‚¤ã‚º: 12px
è‰²: ã‚»ã‚«ãƒ³ãƒ€ãƒªãƒ†ã‚­ã‚¹ãƒˆè‰²
è­¦å‘Š: æ®‹ã‚Š20%ã§è­¦å‘Šè‰²
```

---

## Props / ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿

### TypeScript (React Native)

```typescript
interface InputProps {
  // å€¤ã¨ãƒãƒ³ãƒ‰ãƒ©ãƒ¼
  value: string;
  onChangeText: (text: string) => void;

  // ãƒ©ãƒ™ãƒ«ãƒ»ãƒ—ãƒ¬ãƒ¼ã‚¹ãƒ›ãƒ«ãƒ€ãƒ¼
  label?: string;
  placeholder?: string;
  helperText?: string;

  // å…¥åŠ›ã‚¿ã‚¤ãƒ—
  type?: 'text' | 'email' | 'password' | 'number' | 'phone';
  keyboardType?: KeyboardTypeOptions;
  secureTextEntry?: boolean;
  multiline?: boolean;
  numberOfLines?: number;

  // çŠ¶æ…‹
  error?: string;
  disabled?: boolean;
  required?: boolean;

  // åˆ¶é™
  maxLength?: number;
  showCharacterCount?: boolean;

  // ã‚¢ã‚¤ã‚³ãƒ³
  leadingIcon?: React.ReactNode;
  trailingIcon?: React.ReactNode;
  onTrailingIconPress?: () => void;

  // ãã®ä»–
  autoFocus?: boolean;
  autoCapitalize?: 'none' | 'sentences' | 'words' | 'characters';
  autoComplete?: string;
  returnKeyType?: ReturnKeyTypeOptions;
  onSubmitEditing?: () => void;

  // ã‚¹ã‚¿ã‚¤ãƒ«
  style?: ViewStyle;
  inputStyle?: TextStyle;
}
```

### Swift (SwiftUI)

```swift
struct AppTextField: View {
    // å€¤
    @Binding var text: String

    // ãƒ©ãƒ™ãƒ«ãƒ»ãƒ—ãƒ¬ãƒ¼ã‚¹ãƒ›ãƒ«ãƒ€ãƒ¼
    var label: String? = nil
    var placeholder: String = ""
    var helperText: String? = nil

    // çŠ¶æ…‹
    var error: String? = nil
    var isDisabled: Bool = false
    var isRequired: Bool = false

    // åˆ¶é™
    var maxLength: Int? = nil
    var showCharacterCount: Bool = false

    // ã‚¢ã‚¤ã‚³ãƒ³
    var leadingIcon: Image? = nil
    var trailingIcon: Image? = nil
    var onTrailingIconTap: (() -> Void)? = nil

    // ãƒ•ã‚©ãƒ¼ã‚«ã‚¹
    @FocusState private var isFocused: Bool
}
```

---

## å®Ÿè£…ä¾‹

### TypeScript (React Native)

```typescript
import React, { useState } from 'react';
import {
  View,
  Text,
  TextInput,
  StyleSheet,
  TouchableOpacity,
  ViewStyle,
} from 'react-native';
import { Colors } from '@/constants/Colors';

interface InputProps {
  value: string;
  onChangeText: (text: string) => void;
  label?: string;
  placeholder?: string;
  helperText?: string;
  error?: string;
  disabled?: boolean;
  required?: boolean;
  maxLength?: number;
  showCharacterCount?: boolean;
  secureTextEntry?: boolean;
  multiline?: boolean;
  numberOfLines?: number;
  style?: ViewStyle;
}

export function Input({
  value,
  onChangeText,
  label,
  placeholder,
  helperText,
  error,
  disabled = false,
  required = false,
  maxLength,
  showCharacterCount = false,
  secureTextEntry = false,
  multiline = false,
  numberOfLines = 1,
  style,
}: InputProps) {
  const [isFocused, setIsFocused] = useState(false);
  const hasError = !!error;

  return (
    <View style={[styles.container, style]}>
      {/* ãƒ©ãƒ™ãƒ« */}
      {label && (
        <Text style={styles.label}>
          {label}
          {required && <Text style={styles.required}> *</Text>}
        </Text>
      )}

      {/* å…¥åŠ›ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ */}
      <View
        style={[
          styles.inputContainer,
          isFocused && styles.inputFocused,
          hasError && styles.inputError,
          disabled && styles.inputDisabled,
        ]}
      >
        <TextInput
          value={value}
          onChangeText={onChangeText}
          placeholder={placeholder}
          placeholderTextColor={Colors.light.textTertiary}
          editable={!disabled}
          secureTextEntry={secureTextEntry}
          multiline={multiline}
          numberOfLines={numberOfLines}
          maxLength={maxLength}
          onFocus={() => setIsFocused(true)}
          onBlur={() => setIsFocused(false)}
          style={[
            styles.input,
            multiline && styles.multilineInput,
            disabled && styles.disabledText,
          ]}
        />
      </View>

      {/* ãƒ˜ãƒ«ãƒ‘ãƒ¼ãƒ†ã‚­ã‚¹ãƒˆ / ã‚¨ãƒ©ãƒ¼ / æ–‡å­—æ•° */}
      <View style={styles.footer}>
        {(error || helperText) && (
          <Text style={[styles.helperText, hasError && styles.errorText]}>
            {error || helperText}
          </Text>
        )}

        {showCharacterCount && maxLength && (
          <Text style={styles.characterCount}>
            {value.length} / {maxLength}
          </Text>
        )}
      </View>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    marginBottom: 16,
  },

  label: {
    fontSize: 14,
    fontWeight: '500',
    color: Colors.light.text,
    marginBottom: 6,
  },

  required: {
    color: Colors.light.error,
  },

  inputContainer: {
    backgroundColor: Colors.light.backgroundSecondary,
    borderRadius: 12,
    borderWidth: 1,
    borderColor: 'transparent',
  },

  inputFocused: {
    backgroundColor: Colors.light.background,
    borderWidth: 2,
    borderColor: Colors.light.primary,
  },

  inputError: {
    backgroundColor: 'rgba(244, 67, 54, 0.05)',
    borderWidth: 2,
    borderColor: Colors.light.error,
  },

  inputDisabled: {
    backgroundColor: '#F0F0F0',
    opacity: 0.6,
  },

  input: {
    height: 48,
    paddingHorizontal: 16,
    fontSize: 16,
    color: Colors.light.text,
  },

  multilineInput: {
    height: 'auto',
    minHeight: 100,
    paddingVertical: 12,
    textAlignVertical: 'top',
  },

  disabledText: {
    color: Colors.light.textTertiary,
  },

  footer: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    marginTop: 4,
  },

  helperText: {
    fontSize: 12,
    color: Colors.light.textSecondary,
  },

  errorText: {
    color: Colors.light.error,
  },

  characterCount: {
    fontSize: 12,
    color: Colors.light.textSecondary,
  },
});
```

### Swift (SwiftUI)

```swift
import SwiftUI

struct AppTextField: View {
    @Binding var text: String

    var label: String? = nil
    var placeholder: String = ""
    var helperText: String? = nil
    var error: String? = nil
    var isDisabled: Bool = false
    var isRequired: Bool = false
    var maxLength: Int? = nil
    var showCharacterCount: Bool = false

    @FocusState private var isFocused: Bool

    private var hasError: Bool { error != nil }

    var body: some View {
        VStack(alignment: .leading, spacing: 6) {
            // ãƒ©ãƒ™ãƒ«
            if let label = label {
                HStack(spacing: 2) {
                    Text(label)
                        .font(.system(size: 14, weight: .medium))
                        .foregroundColor(AppColors.textPrimary)

                    if isRequired {
                        Text("*")
                            .foregroundColor(AppColors.error)
                    }
                }
            }

            // å…¥åŠ›ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰
            TextField(placeholder, text: $text)
                .focused($isFocused)
                .disabled(isDisabled)
                .padding(.horizontal, 16)
                .frame(height: 48)
                .background(backgroundColor)
                .cornerRadius(12)
                .overlay(
                    RoundedRectangle(cornerRadius: 12)
                        .stroke(borderColor, lineWidth: isFocused || hasError ? 2 : 0)
                )
                .onChange(of: text) { newValue in
                    if let maxLength = maxLength, newValue.count > maxLength {
                        text = String(newValue.prefix(maxLength))
                    }
                }

            // ãƒ•ãƒƒã‚¿ãƒ¼
            HStack {
                // ãƒ˜ãƒ«ãƒ‘ãƒ¼ãƒ†ã‚­ã‚¹ãƒˆ / ã‚¨ãƒ©ãƒ¼
                if let error = error {
                    Text(error)
                        .font(.system(size: 12))
                        .foregroundColor(AppColors.error)
                } else if let helperText = helperText {
                    Text(helperText)
                        .font(.system(size: 12))
                        .foregroundColor(AppColors.textSecondary)
                }

                Spacer()

                // æ–‡å­—æ•°ã‚«ã‚¦ãƒ³ã‚¿ãƒ¼
                if showCharacterCount, let maxLength = maxLength {
                    Text("\(text.count) / \(maxLength)")
                        .font(.system(size: 12))
                        .foregroundColor(AppColors.textSecondary)
                }
            }
        }
        .opacity(isDisabled ? 0.6 : 1.0)
    }

    private var backgroundColor: Color {
        if isDisabled {
            return Color(hex: "F0F0F0")
        } else if hasError {
            return Color(hex: "F44336").opacity(0.05)
        } else if isFocused {
            return AppColors.background
        } else {
            return AppColors.secondaryBackground
        }
    }

    private var borderColor: Color {
        if hasError {
            return AppColors.error
        } else if isFocused {
            return AppColors.primary
        } else {
            return .clear
        }
    }
}

// ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼
#Preview {
    VStack(spacing: 20) {
        AppTextField(
            text: .constant(""),
            label: "åå‰",
            placeholder: "åå‰ã‚’å…¥åŠ›",
            isRequired: true
        )

        AppTextField(
            text: .constant("å…¥åŠ›æ¸ˆã¿ãƒ†ã‚­ã‚¹ãƒˆ"),
            label: "ãƒ¡ãƒ¢",
            placeholder: "ãƒ¡ãƒ¢ã‚’å…¥åŠ›",
            helperText: "ä»»æ„é …ç›®ã§ã™"
        )

        AppTextField(
            text: .constant("ã‚¨ãƒ©ãƒ¼ã‚ã‚Š"),
            label: "ãƒ¡ãƒ¼ãƒ«ã‚¢ãƒ‰ãƒ¬ã‚¹",
            placeholder: "example@email.com",
            error: "æ­£ã—ã„ãƒ¡ãƒ¼ãƒ«ã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„"
        )

        AppTextField(
            text: .constant("Hello"),
            label: "ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸",
            placeholder: "ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’å…¥åŠ›",
            maxLength: 100,
            showCharacterCount: true
        )
    }
    .padding()
}
```

---

## ã‚¢ã‚¯ã‚»ã‚·ãƒ“ãƒªãƒ†ã‚£

### å¿…é ˆå¯¾å¿œ

- [ ] `accessibilityLabel` ã«ãƒ©ãƒ™ãƒ«ã‚’è¨­å®š
- [ ] ã‚¨ãƒ©ãƒ¼æ™‚ã¯ `accessibilityHint` ã§ã‚¨ãƒ©ãƒ¼å†…å®¹ã‚’é€šçŸ¥
- [ ] å¿…é ˆãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã¯éŸ³å£°ã§ä¼ãˆã‚‹
- [ ] ãƒ•ã‚©ãƒ¼ã‚«ã‚¹é †åºã‚’é©åˆ‡ã«è¨­å®š

### VoiceOverå¯¾å¿œ

```swift
TextField(placeholder, text: $text)
    .accessibilityLabel(label ?? placeholder)
    .accessibilityHint(error ?? helperText ?? "")
    .accessibilityValue(text.isEmpty ? "ç©º" : text)
```

---

## ãƒã‚§ãƒƒã‚¯ãƒªã‚¹ãƒˆ

- [ ] å…¨ã‚¿ã‚¤ãƒ—ï¼ˆtext, email, passwordç­‰ï¼‰ã‚’å®Ÿè£…
- [ ] ãƒ©ãƒ™ãƒ«ãƒ»ãƒ˜ãƒ«ãƒ‘ãƒ¼ãƒ†ã‚­ã‚¹ãƒˆå¯¾å¿œ
- [ ] ã‚¨ãƒ©ãƒ¼çŠ¶æ…‹ã‚’å®Ÿè£…
- [ ] ç„¡åŠ¹çŠ¶æ…‹ã‚’å®Ÿè£…
- [ ] æ–‡å­—æ•°ã‚«ã‚¦ãƒ³ã‚¿ãƒ¼å®Ÿè£…
- [ ] ã‚¢ã‚¤ã‚³ãƒ³å¯¾å¿œ
- [ ] ã‚¢ã‚¯ã‚»ã‚·ãƒ“ãƒªãƒ†ã‚£å¯¾å¿œ
- [ ] ãƒ€ãƒ¼ã‚¯ãƒ¢ãƒ¼ãƒ‰å¯¾å¿œ
